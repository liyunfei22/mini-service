认证
认证是大多数应用程序的一个重要部分。有许多不同的方法和策略来处理认证。任何项目采取的方法都取决于其特定的应用要求。本章介绍了几种可以适应各种不同要求的认证方法。

Passport是最流行的node.js认证库，为社区所熟知，并成功用于许多生产应用。使用@nestjs/passport模块将该库与Nest应用程序集成是很直接的。在高层次上，Passport执行了一系列步骤，以。

通过验证用户的 "凭证"（如用户名/密码、JSON网络令牌（JWT）或来自身份提供者的身份令牌）来认证用户
管理认证状态（通过发布一个便携式令牌，如JWT，或创建一个Express会话）。
将有关认证用户的信息附加到请求对象上，以便在路由处理程序中进一步使用。
Passport有一个丰富的策略生态系统，可以实现各种认证机制。虽然概念简单，但你可以选择的Passport策略集是很大的，而且呈现出很多多样性。Passport将这些不同的步骤抽象为一种标准模式，@nestjs/passport模块将这种模式包装并标准化为熟悉的Nest结构。

在本章中，我们将使用这些强大而灵活的模块为 RESTful API 服务器实现一个完整的端到端认证解决方案。你可以使用这里描述的概念来实现任何Passport策略来定制你的认证方案。你可以按照本章的步骤来构建这个完整的例子。你可以在这里找到一个带有完整示例应用的资源库。

认证要求#
让我们充实一下我们的要求。在这个用例中，客户将首先用一个用户名和密码进行认证。一旦通过认证，服务器将发出一个JWT，可以在后续请求的授权头中作为承载令牌发送，以证明认证。我们还将创建一个受保护的路由，只有包含有效JWT的请求才能访问。

我们将从第一个需求开始：验证一个用户。然后，我们将通过发布JWT来扩展它。最后，我们将创建一个受保护的路由，检查请求中是否有有效的JWT。

首先，我们需要安装所需的软件包。Passport提供了一个名为passport-local的策略，实现了一个用户名/密码认证机制，这适合我们这部分用例的需要。

注意事项
对于你选择的任何Passport策略，你总是需要@nestjs/passport 和 passport 包。然后，你需要安装特定策略的包（例如passport-jwt或passport-local），以实现你正在构建的特定认证策略。此外，你还可以安装任何Passport策略的类型定义，如上图的@types/passport-local，在编写TypeScript代码时提供帮助。

实施Passport策略#
我们现在准备实现认证功能。我们将首先概述用于任何Passport策略的过程。把Passport看作是一个小型框架本身是很有帮助的。该框架的优雅之处在于，它将认证过程抽象为几个基本步骤，你可以根据你实现的策略进行定制。它像一个框架，因为你通过提供定制参数（作为普通的JSON对象）和回调函数形式的定制代码来配置它，Passport在适当的时候调用。@nestjs/passport模块将该框架包装在Nest风格的包中，使其易于集成到Nest应用程序中。我们将在下面使用@nestjs/passport，但首先让我们考虑一下vanilla Passport是如何工作的。

在vanilla Passport中，你通过提供两件事来配置一个策略。

1. 一组特定于该策略的选项。例如，在JWT策略中，你可以提供一个秘密来签署令牌。
2. 一个 "验证回调"，这是你告诉Passport如何与你的用户商店（你管理用户账户的地方）互动的地方。在这里，你验证一个用户是否存在（和/或创建一个新用户），以及他们的凭证是否有效。如果验证成功，Passport库希望这个回调返回一个完整的用户，如果失败，则返回一个空值（失败的定义是没有找到用户，或者在passport-local的情况下，密码不匹配）。

通过@nestjs/passport，你可以通过扩展PassportStrategy类来配置一个Passport策略。你通过在你的子类中调用super()方法来传递策略选项（上面第1项），可以选择传递一个选项对象。你通过在你的子类中实现一个 validate() 方法来提供验证回调（上面第 2 项）。

我们将首先生成一个AuthModule，并在其中生成一个AuthService。


替换这些生成文件的默认内容，如下所示。对于我们的示例应用程序，UsersService只是维护了一个硬编码的内存中的用户列表，以及一个按用户名检索的查找方法。在一个真正的应用程序中，这是你建立你的用户模型和持久层的地方，使用你选择的库（例如TypeORM、Sequelize、Mongoose等）。

在UsersModule中，唯一需要改变的是将UsersService添加到@Module装饰器的出口数组中，以便它在这个模块之外是可见的（我们很快将在我们的AuthService中使用它）。

我们的AuthService的工作是检索一个用户并验证密码。我们为此目的创建了一个validateUser()方法。在下面的代码中，我们使用一个方便的ES6传播操作符，在返回用户对象之前将密码属性剥离。我们稍后将从我们的Passport本地策略中调用validateUser()方法。

警告
当然，在真正的应用中，你不会用纯文本存储密码。你会使用像bcrypt这样的库，并使用加盐的单向哈希算法。有了这种方法，你就可以只存储散列的密码，然后将存储的密码与传入的密码的散列版本进行比较，这样就不会以纯文本存储或暴露用户的密码。为了使我们的示例程序保持简单，我们违反了这一绝对授权，使用了纯文本。不要在你真正的应用程序中这样做!

现在，我们更新我们的AuthModule以导入UsersModule。

实施Passport本地#
现在我们可以实现我们的Passport本地认证策略。在auth文件夹中创建一个名为local.strategy.ts的文件，并添加以下代码。

我们遵循前面描述的所有Passport策略的秘诀。在我们使用passport-local的情况下，没有配置选项，所以我们的构造函数只是简单地调用super()，没有选项对象。

提示
我们可以在调用super()时传递一个options对象来定制护照策略的行为。在这个例子中，passport-local策略默认期望在请求体中有名为用户名和密码的属性。传递一个选项对象来指定不同的属性名称，例如：super({ usernameField: 'email' })。更多信息请参见Passport文档。


我们还实现了validate()方法。对于每个策略，Passport将使用适当的策略特定参数集调用验证函数（用@nestjs/passport中的validate()方法实现）。对于本地策略，Passport希望有一个验证()方法，其签名如下： validate(username: string, password:string): any.

大部分验证工作是在我们的AuthService中完成的（在我们的UsersService的帮助下），所以这个方法是非常直接的。任何Passport策略的validate()方法都将遵循类似的模式，只是在凭证如何表示的细节方面有所不同。如果找到了一个用户，并且凭证有效，则返回该用户，以便Passport能够完成其任务（例如，在Request对象上创建用户属性），并且请求处理管道可以继续。如果没有找到，我们就抛出一个异常，让我们的异常层处理它。

通常情况下，每个策略的validate()方法的唯一显著区别是你如何确定一个用户是否存在并且是有效的。例如，在JWT策略中，根据需求，我们可以评估解码令牌中携带的userId是否与我们的用户数据库中的记录相匹配，或者与被撤销的令牌列表相匹配。因此，这种子类化和实现特定策略验证的模式是一致的、优雅的和可扩展的。

我们需要配置我们的AuthModule以使用我们刚刚定义的Passport功能。更新auth.module.ts，使其看起来像这样。

内置的Passport护卫#
Guards 章节描述了 Guards 的主要功能：确定一个请求是否会被路由处理程序处理。这一点仍然正确，而且我们很快就会使用这一标准能力。然而，在使用@nestjs/passport模块的情况下，我们还将引入一个小小的新问题，一开始可能会让人感到困惑，所以我们现在就来讨论这个问题。从认证的角度考虑，你的应用程序可以存在于两种状态。

用户/客户未登录（未被认证）
用户/客户已登录（已通过认证）
在第一种情况下（用户没有登录），我们需要执行两个不同的功能。

限制未认证的用户可以访问的路由（即拒绝访问受限的路由）。我们将以熟悉的方式使用卫兵来处理这个功能，在受保护的路由上放置一个卫兵。正如你所预料的，我们将在这个Guard中检查是否存在有效的JWT，所以我们将在以后的工作中处理这个Guard，一旦我们成功发布了JWT。

当先前未认证的用户试图登录时，启动认证步骤本身。这是我们要向有效用户发布JWT的步骤。思考一下，我们知道我们需要POST用户名/密码凭证来启动认证，所以我们将设置一个POST /auth/login路由来处理。这就提出了一个问题：我们究竟如何在该路由中调用passport-local策略？

答案很简单：通过使用另一个稍微不同的Guard。@nestjs/passport模块为我们提供了一个内置的Guard，可以为我们做这件事。该Guard调用Passport策略，并启动上述步骤（检索凭证、运行验证函数、创建用户属性等）。

上面列举的第二种情况（登录的用户）只是依靠我们已经讨论过的标准类型的Guard来实现登录用户对受保护路线的访问。

登录路由#
有了这个策略，我们现在可以实现一个原始的/auth/login路由，并应用内置的Guard来启动护照-本地流。

打开app.controller.ts文件，将其内容替换为以下内容。

通过@UseGuards(AuthGuard('local'))，我们正在使用@nestjs/passporta在我们扩展passport-local策略时为我们自动提供的AuthGuard。让我们来分析一下。我们的Passport本地策略有一个默认的名字 "local"。我们在@UseGuards()装饰器中引用该名称，以便将其与passport-local包提供的代码联系起来。如果我们的应用程序中有多个Passport策略（每个策略都可能提供一个特定于策略的AuthGuard），这将被用来区分调用哪个策略。虽然到目前为止我们只有一个这样的策略，但我们很快就会添加第二个，所以需要这个来区分。

为了测试我们的路由，我们将让我们的/auth/login路由暂时简单地返回用户。这也让我们展示Passport的另一个功能。Passport根据我们从validate()方法返回的值自动创建一个用户对象，并将其作为req.user分配给Request对象。稍后，我们将用创建和返回JWT的代码来取代它。

由于这些是API路由，我们将使用常用的cURL库来测试它们。你可以用UsersService中硬编码的任何用户对象进行测试。

虽然这样做可以，但直接将策略名称传递给AuthGuard()会在代码库中引入魔法字符串。相反，我们建议创建你自己的类，如下所示。

现在，我们可以更新/auth/login路由处理程序并使用LocalAuthGuard来代替。


